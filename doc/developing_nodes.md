# How to develop your own node for avplumber


## Directory structure

Source codes of all nodes reside in `src/nodes/` directory. Each `.cpp` file corresponds to one or more nodes.

There are also subdirectories, included conditionally depending on flags set in `Makefile`. For example, if your node is useful only for debugging purposes (e.g. it is intentionally corrupting packets to test recovery code), you should put it in `debug/` directory.

Directories are scanned using a shell script (`generate_nodes_list`) and a `find` command inside `Makefile`, when `make` is run. There is no index file in sources (it is generated automatically when compiling), so you don't need to update anything after adding `.cpp` file to `src/nodes/` directory or subdirectory.


## Node source file

It begins with:

`#include "node_common.hpp"`

which includes commonly used headers and `DECLNODE` macros (see below).

Then classes or class templates of nodes follow.

After class or class template is defined, `DECLNODE` macros need to be used to enable node creation and include it in the autogenerated index.


## DECLNODE macros

They serve 2 functions:

* `generate_nodes_list` scrips searches for them in all nodes sources and generates the nodes index
* they are parsed by C++ preprocessor (as every macro in C/C++ source code), generating code needed for node creation

Available macros:

* `DECLNODE(nodetype, classname)` - declares a node which will be created when `type` parameter in node's JSON object equals `nodetype`. The node must be defined in `classname` class.
* `DECLNODE_ATD(nodetype, tplname)` - declares a node which will be created when `type` parameter in node's JSON object equals `nodetype`. The node template must be defined in `tplname` class template. It will be specialized for single template argument being the type of data processed in this node. If the node has both input(s) and output(s), input and output types must be the same. `ATD` means automatic type detection.
* `DECLNODE_ALIAS(nodetype, classname)` - declares a different type name for a node already declared using `DECLNODE`
* `DECLNODE_ATD_ALIAS(nodetype, tplname)` - declares a different type name for a node already declared using `DECLNODE_ATD`


## Blocking or non-blocking?

Arguments for blocking nodes:

* good for blocking operations on the file system & network
* good for computationally expensive operations: video & audio encoding, decoding and processing

Arguments for non-blocking nodes:

* less overhead (no context switch when passing data between nodes)
* more predictible timing

avplumber supported only blocking nodes for a very long time, thus even nodes that would benefit from being non-blocking are still implemented as blocking.


## Node API

Every node class needs to inherit from `Node`. If the node is blocking, the only virtual function that absolutely needs to be overriden is `process`. Example: `firewall` node which doesn't allow packets or frames without PTS to pass:

```c++
    virtual void process() {
        T data = this->source_->get();
        if (!data.pts().isValid()) return;
        this->sink_->put(data);
    }
```

If the node is non-blocking, the function to override is `processNonBlocking`.

Also, static method `create` needs to be defined in the class.


## Helper derived classes

Commonly used node source & sink patterns are available as base classes or templates derived from Node:

* `NodeSingleInput<InputType>`
  * use `this->source_->get()` (blocking function) to get packet/frame
  * or `this->source_->peek(0)` (0 to make it non-blocking) and `this->source_->pop()`
* `NodeSingleOutput<OutputType>`
  * use `this->sink_->put(packet_or_frame)` to output the packet/frame to the next node in the graph
* `NodeSISO<InputType, OutputType>` (Single Input, Single Output) - combines `NodeSingleInput` and `NodeSingleOutput`
* `NodeMultiInput<InputType>`
  * use `int i = findSourceWithData()` to get index of source edge that has packet/frame waiting to be read. If returned value isn't -1, read if using `this->source_edges_[i]->peek()` and call `this->source_edges_[i]->pop()` when you've done using it (i.e. you've passed it along to the next node, or it is to be discarded)
* `NodeMultiOutputs<OutputType>`
  * use `this->sink_edges_[output_index]->enqueue(packet_or_frame)` (blocking function) to output packet/frame
  * or `this->sink_edges_[output_index]->try_enqueue(packet_or_frame)` for non-blocking operation

These bases define their own constructors, you should call them in your constructor or write `using BaseTemplate<TemplateArgument>::BaseTemplate;` to explicitly use base constructor in derived class.

You should generally use one or more of these bases, since they override virtual methods and implement interfaces important for internal avplumber operation. If you want to implement them on your own (because you need, for example, mixed data types on input or output), look at `src/nodes/filters.cpp` and `src/graph_base.hpp` for inspiration.

Thanks to multiple inheritance, you can use most of these bases in non-blocking nodes, too. See `src/nodes/realtime.cpp` for example.


TBC...